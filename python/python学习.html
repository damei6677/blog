<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.编码1# _*_ coding: utf-8 _*_	  2.函数说明“””类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算””” #– 寻求帮助:​    dir(obj)            # 简单的列出对象obj所包含的方法名称，返回一个字符串列表​    help(obj.func">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/damei6677/python/python%E5%AD%A6%E4%B9%A0.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.编码1# _*_ coding: utf-8 _*_	  2.函数说明“””类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算””” #– 寻求帮助:​    dir(obj)            # 简单的列出对象obj所包含的方法名称，返回一个字符串列表​    help(obj.func">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-04T03:36:07.062Z">
<meta property="article:modified_time" content="2022-10-08T06:25:41.157Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/blog/css/style.css">

  
    
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/blog/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/damei6677"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="page-" class="h-entry article article-type-page" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/blog/python/python%E5%AD%A6%E4%B9%A0.html" class="article-date">
  <time class="dt-published" datetime="2022-11-04T03:36:07.062Z" itemprop="datePublished">2022-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-编码"><a href="#1-编码" class="headerlink" title="1.编码"></a>1.编码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding: utf-8 _*_	</span></span><br></pre></td></tr></table></figure>

<h1 id="2-函数说明"><a href="#2-函数说明" class="headerlink" title="2.函数说明"></a>2.函数说明</h1><p>“””类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算—-类型和运算”””</p>
<p>#– 寻求帮助:<br>​    dir(obj)            # 简单的列出对象obj所包含的方法名称，返回一个字符串列表<br>​    help(obj.func)      # 查询obj.func的具体介绍和用法</p>
<h1 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="3.基本数据类型"></a>3.基本数据类型</h1><p>#– 测试类型的三种方法，推荐第三种</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(L) == <span class="built_in">type</span>([]): <span class="built_in">print</span>(<span class="string">&quot;L is list&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">type</span>(L) == <span class="built_in">list</span>: <span class="built_in">print</span>(<span class="string">&quot;L is list&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(L, <span class="built_in">list</span>): <span class="built_in">print</span>(<span class="string">&quot;L is list&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>#– Python数据类型：哈希类型、不可哈希类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈希类型，即在原地不能改变的变量类型，不可变类型</span><br><span class="line">可利用<span class="built_in">hash</span>函数查看其<span class="built_in">hash</span>值，也可以作为字典的key</span><br></pre></td></tr></table></figure>
<p>​    “数字类型：int, float, decimal.Decimal, fractions.Fraction, complex”<br>​    “字符串类型：str, bytes”<br>​    “元组：tuple”<br>​    “冻结集合：frozenset”<br>​    “布尔类型：True, False”<br>​    “None”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不可<span class="built_in">hash</span>类型：原地可变类型：<span class="built_in">list</span>、<span class="built_in">dict</span>和<span class="built_in">set</span></span><br><span class="line">它们不可以作为字典的key</span><br></pre></td></tr></table></figure>

<p>#– 数字常量<br>​    1234, -1234, 0, 999999999                         # 整数<br>​    1.23, 1., 3.14e-10, 4E210, 4.0e+210          # 浮点数<br>​    0o177, 0x9ff, 0X9FF, 0b101010                 # 八进制、十六进制、二进制数字<br>​    3+4j, 3.0+4.0j, 3J                    # 复数常量，也可以用complex(real, image)来创建<br>​    hex(I), oct(I), bin(I)                 # 将十进制数转化为十六进制、八进制、二进制表示的“字符串”<br>​    int(string, base)                     # 将字符串转化为整数，base为进制数<br>​ # 2.x中，有两种整数类型：一般整数（32位）和长整数（无穷精度）。可以用l或L结尾，迫使一般整数成为长整数<br>​    float(‘inf’), float(‘-inf’), float(‘nan’)    # 无穷大, 无穷小, 非数<br>​<br>#– 数字的表达式操作符<br>​    yield x                                      # 生成器函数发送协议<br>​    lambda args: expression      # 生成匿名函数<br>​    x if y else z                              # 三元选择表达式<br>​    x and y, x or y, not x              # 逻辑与、逻辑或、逻辑非<br>​    x in y, x not in y                      # 成员对象测试<br>​    x is y, x is not y                       # 对象实体测试<br>​    x&lt;y, x&lt;&#x3D;y, x&gt;y, x&gt;&#x3D;y, x&#x3D;&#x3D;y, x!&#x3D;y             # 大小比较，集合子集或超集值相等性操作符<br>​    1 &lt; a &lt; 3                                   # Python中允许连续比较<br>​    x|y, x&amp;y, x^y                           # 位或、位与、位异或<br>​    x&lt;&lt;y, x&gt;&gt;y                               # 位操作：x左移、右移y位<br>​    +, -, *, &#x2F;, &#x2F;&#x2F;, %, **                     # 真除法、floor除法：返回不大于真除法结果的整数值、取余、幂运算<br>​    -x, +x, ~x                                  # 一元减法、识别、按位求补（取反）<br>​    x[i], x[i:j:k]                                # 索引、分片、调用<br>​    int(3.14), float(3)                     # 强制类型转换<br>​<br>#– 整数可以利用bit_length函数测试所占的位数<br>​    a &#x3D; 1;       a.bit_length()    # 1<br>​    a &#x3D; 1024;    a.bit_length()    # 11<br>​<br>#– repr和str显示格式的区别<br>​    “””<br>​    repr格式：默认的交互模式回显，产生的结果看起来它们就像是代码。<br>​    str格式：打印语句，转化成一种对用户更加友好的格式。<br>​    “””<br>​<br>#– 数字相关的模块<br>​    # math模块<br>​    # Decimal模块：小数模块<br>​        import decimal<br>​        from decimal import Decimal<br>​        Decimal(“0.01”) + Decimal(“0.02”)        # 返回Decimal(“0.03”)<br>​        decimal.getcontext().prec &#x3D; 4                # 设置全局精度为4 即小数点后边4位<br>​    #– Fraction模块：分数模块<br>​        from fractions import Fraction<br>​        x &#x3D; Fraction(4, 6)                       # 分数类型 4&#x2F;6<br>​        x &#x3D; Fraction(“0.25”)                   # 分数类型 1&#x2F;4 接收字符串类型的参数</p>
<h1 id="4-集合set"><a href="#4-集合set" class="headerlink" title="4.集合set"></a>4.集合set</h1><p>​    “””<br>​    set是一个无序不重复元素集, 基本功能包括<code>关系测试</code>和<code>消除重复元素</code>。<br>​    set支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算。<br>​    set支持x in set, len(set), for x in set。<br>​    set不记录元素位置或者插入点, 因此不支持indexing, slicing, 或其它类序列的操作<br>​    “””</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>])                          <span class="comment"># 创建一个数值集合，返回&#123;3, 5, 9, 10&#125;</span></span><br><span class="line">t = <span class="built_in">set</span>(<span class="string">&quot;Hello&quot;</span>)                             <span class="comment"># 创建一个唯一字符的集合返回&#123;&#125;</span></span><br><span class="line">a = t | s;    t.union(s)                     <span class="comment"># t 和 s的并集</span></span><br><span class="line">b = t &amp; s;    t.intersection(s)              <span class="comment"># t 和 s的交集</span></span><br><span class="line">c = t – s;    t.difference(s)                <span class="comment"># 求差集（项在t中, 但不在s中）</span></span><br><span class="line">d = t ^ s;    t.symmetric_difference(s)      <span class="comment"># 对称差集（项在t或s中, 但不会同时出现在二者中）</span></span><br><span class="line">t.add(<span class="string">&#x27;x&#x27;</span>);   t.remove(<span class="string">&#x27;H&#x27;</span>)                  <span class="comment"># 增加/删除一个item</span></span><br><span class="line">t.update([<span class="number">10</span>,<span class="number">37</span>,<span class="number">42</span>])                         <span class="comment"># 利用[......]更新s集合</span></span><br><span class="line">x <span class="keyword">in</span> s,  x <span class="keyword">not</span> <span class="keyword">in</span> s                          <span class="comment"># 集合中是否存在某个值</span></span><br><span class="line">s.issubset(t); s.issuperset(t); s.copy(); s.discard(x); s.clear()</span><br><span class="line">&#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;                 <span class="comment"># 集合解析，结果：&#123;16, 1, 4, 9&#125;</span></span><br><span class="line">&#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;spam&#x27;</span>&#125;                          <span class="comment"># 集合解析，结果：&#123;&#x27;a&#x27;, &#x27;p&#x27;, &#x27;s&#x27;, &#x27;m&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="frozenset"><a href="#frozenset" class="headerlink" title="frozenset"></a>frozenset</h3><p>​    #– 集合frozenset，不可变对象<br>​    “””<br>​    set是可变对象，即不存在hash值，不能作为字典的键值。同样的还有list、tuple等<br>​    frozenset是不可变对象，即存在hash值，可作为字典的键值<br>​    frozenset对象没有add、remove等方法，但有union&#x2F;intersection&#x2F;difference等方法<br>​    “””<br>​    a &#x3D; set([1, 2, 3])<br>​    b &#x3D; set()<br>​    b.add(a)                     # error: set是不可哈希类型<br>​    b.add(frozenset(a))          # ok，将set变为frozenset，可哈希</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = <span class="built_in">frozenset</span>(<span class="built_in">range</span>(<span class="number">10</span>))     <span class="comment"># 生成一个新的不可变集合</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="built_in">frozenset</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="built_in">frozenset</span>(<span class="string">&#x27;runoob&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="built_in">frozenset</span>([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;n&#x27;</span>])   <span class="comment"># 创建不可变集合</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



<p>#– 布尔类型bool<br>​    type(True)                   # 返回&lt;class ‘bool’&gt;<br>​    isinstance(False, int)       # bool类型属于整形，所以返回True<br>​    True &#x3D;&#x3D; 1; True is 1         # 输出(True, False)<br>​<br>#– 动态类型简介<br>​    “””<br>​    变量名通过引用，指向对象。<br>​    Python中的“类型”属于对象，而不是变量，每个对象都包含有头部信息，比如”类型标示符” “引用计数器”等<br>​    “””<br>​    #共享引用及在原处修改：对于可变对象，要注意尽量不要共享引用！<br>​    #共享引用和相等测试：<br>​        L &#x3D; [1], M &#x3D; [1], L is M            # 返回False<br>​        L &#x3D; M &#x3D; [1, 2, 3], L is M           # 返回True，共享引用<br>​    #增强赋值和共享引用：普通+号会生成新的对象，而增强赋值+&#x3D;会在原处修改<br>​        L &#x3D; M &#x3D; [1, 2]<br>​        L &#x3D; L + [3, 4]                      # L &#x3D; [1, 2, 3, 4], M &#x3D; [1, 2]<br>​        L +&#x3D; [3, 4]                         # L &#x3D; [1, 2, 3, 4], M &#x3D; [1, 2, 3, 4]</p>
<h1 id="5-列表"><a href="#5-列表" class="headerlink" title="5.列表"></a>5.列表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span></span><br><span class="line">序列是Python中最基本的数据结构。</span><br><span class="line"></span><br><span class="line">序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是<span class="number">0</span>，第二个索引是<span class="number">1</span>，依此类推。</span><br><span class="line"></span><br><span class="line">Python有<span class="number">6</span>个序列的内置类型，但最常见的是列表和元组。</span><br><span class="line">序列都可以进行的操作包括索引，切片，加，乘，检查成员。</span><br><span class="line"></span><br><span class="line">此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。</span><br><span class="line">列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。</span><br><span class="line"></span><br><span class="line">列表的数据项不需要具有相同的类型</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<p>#– 常用列表常量和操作<br>​    L &#x3D; [[1, 2], ‘string’, {}]                        # 嵌套列表<br>​    L &#x3D; list(‘spam’)                                 # 列表初始化<br>​    L &#x3D; list(range(0, 4))                          # 列表初始化<br>​    list(map(ord, ‘spam’))                       # 列表解析<br>​    len(L)                                             # 求列表长度<br>​    L.count(value)                                    # 求列表中某个值的个数<br>​    L.append(obj)                                     # 向列表的尾部添加数据，比如append(2)，添加元素2<br>​    L.insert(index, obj)                              # 向列表的指定index位置添加数据，index及其之后的数据后移<br>​    L.extend(interable)                               # 通过添加iterable中的元素来扩展列表，比如extend([2])，添加元素2，注意和append的区别<br>​    L.index(value, [start, [stop]])                   # 返回列表中值value的第一个索引<br>​    L.pop([index])                                    # 删除并返回index处的元素，默认为删除并返回最后一个元素<br>​    L.remove(value)                                   # 删除列表中的value值，只删除第一次出现的value的值<br>​    L.reverse()                                       # 反转列表<br>​    L.sort(cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False)         # 排序列表<br>​    a &#x3D; [1, 2, 3], b &#x3D; a[10:]                         # 注意，这里不会引发IndexError异常，只会返回一个空的列表[]<br>​    a &#x3D; [], a +&#x3D; [1]                                  # 这里实在原有列表的基础上进行操作，即列表的id没有改变<br>​    a &#x3D; [], a &#x3D; a + [1]                               # 这里最后的a要构建一个新的列表，即a的id发生了变化<br>​<br>#– 用切片来删除序列的某一段<br>​    a &#x3D; [1, 2, 3, 4, 5, 6, 7]<br>​    a[1:4] &#x3D; []                                       # a &#x3D; [1, 5, 6, 7]<br>​    a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7]<br>​    del a[::2]                                        # 去除偶数项(偶数索引的)，a &#x3D; [1, 3, 5, 7]</p>
<h1 id="6-元组"><a href="#6-元组" class="headerlink" title="6.元组"></a>6.元组</h1><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p>
<p>元组使用小括号，列表使用方括号。</p>
<p>#– 元组和列表的唯一区别在于元组是不可变对象，列表时可变对象<br>​    a &#x3D; [1, 2, 3]           # a[1] &#x3D; 0, OK<br>​    a &#x3D; (1, 2, 3)           # a[1] &#x3D; 0, Error<br>​    a &#x3D; ([1, 2])            # a[0][1] &#x3D; 0, OK<br>​    a &#x3D; [(1, 2)]            # a[0][1] &#x3D; 0, Error<br>​<br>#– 元组的特殊语法: 逗号和圆括号<br>​    D &#x3D; (12)                # 此时D为一个整数 即D &#x3D; 12<br>​    D &#x3D; (12, )              # 此时D为一个元组 即D &#x3D; (12, )5.字符串</p>
<h1 id="7-字典"><a href="#7-字典" class="headerlink" title="7.字典"></a>7.字典</h1><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值(key&#x3D;&gt;value)对用冒号(<strong>:</strong>)分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号(**{})**中 ,格式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure>

<p>键必须是唯一的，但值则不必。</p>
<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p>
<p>一个简单的字典实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;Alice&#x27;</span>: <span class="string">&#x27;2341&#x27;</span>, <span class="string">&#x27;Beth&#x27;</span>: <span class="string">&#x27;9102&#x27;</span>, <span class="string">&#x27;Cecil&#x27;</span>: <span class="string">&#x27;3258&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>也可如此创建字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">456</span> &#125;;</span><br><span class="line">dict2 = &#123; <span class="string">&#x27;abc&#x27;</span>: <span class="number">123</span>, <span class="number">98.6</span>: <span class="number">37</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>#– 常用字典常量和操作<br>​    D &#x3D; {}<br>​    D &#x3D; {‘spam’:2, ‘tol’:{‘ham’:1}}                   # 嵌套字典<br>​    D &#x3D; dict.fromkeys([‘s’, ‘d’], 8)                    # {‘d’: 8, ‘s’: 8}<br>​    D &#x3D; dict(name &#x3D; ‘tom’, age &#x3D; 12)                  # {‘age’: 12, ‘name’: ‘tom’}<br>​    D &#x3D; dict([(‘name’, ‘tom’), (‘age’, 12)])          # {‘age’: 12, ‘name’: ‘tom’}<br>​    D &#x3D; dict(zip([‘name’, ‘age’], [‘tom’, 12]))       # {‘age’: 12, ‘name’: ‘tom’}<br>​    D.keys(); D.values(); D.items()                   # 字典键、值以及键值对<br>​    D.get(key, default)                               # get函数<br>​    D.update(D_other)                                 # 合并字典，如果存在相同的键值，D_other的数据会覆盖掉D的数据<br>​    D.pop(key, [D])                                   # 删除字典中键值为key的项，返回键值为key的值，如果不存在，返回默认值D，否则异常<br>​    D.popitem()                                       # pop字典中的一项（一个键值对）<br>​    D.setdefault(k[, d])                              # 设置D中某一项的默认值。如果k存在，则返回D[k]，否则设置D[k]&#x3D;d，同时返回D[k]。<br>​    del D                                             # 删除字典<br>​    del D[‘key’]                                      # 删除字典的某一项<br>​    if key in D:   if key not in D:                   # 测试字典键是否存在<br>​    # 字典注意事项：（1）对新索引赋值会添加一项（2）字典键不一定非得是字符串，也可以为任何的不可变对象</p>
<p>#– 字典解析<br>​    D &#x3D; {k:8 for k in [‘s’, ‘d’]}                     # {‘d’: 8, ‘s’: 8}<br>​    D &#x3D; {k:v for (k, v) in zip([‘name’, ‘age’], [‘tom’, 12])}<br>​    </p>
<p>#– 字典的特殊方法__missing__：当查找找不到key时，会执行该方法<br>​    class Dict(dict):<br>​        def <strong>missing</strong>(self, key):<br>​            self[key] &#x3D; []<br>​            return self[key]<br>​    dct &#x3D; Dict()<br>​    dct[“foo”].append(1)    # 这有点类似于collections.defalutdict<br>​    dct[“foo”]              # [1]</p>
<h1 id="8-字符串"><a href="#8-字符串" class="headerlink" title="8.字符串"></a>8.字符串</h1><p>#– 常见字符串常量和表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="string">&#x27;&#x27;</span>                   <span class="comment"># 空字符串</span></span><br><span class="line">S = <span class="string">&quot;spam’s&quot;</span>             <span class="comment"># 双引号和单引号相同</span></span><br><span class="line">S = <span class="string">&quot;s\np\ta\x00m&quot;</span>       <span class="comment"># 转义字符</span></span><br><span class="line">S = <span class="string">&quot;&quot;&quot;spam&quot;&quot;&quot;</span>           <span class="comment"># 三重引号字符串，一般用于函数说明</span></span><br><span class="line">S = <span class="string">r&#x27;\temp&#x27;</span>             <span class="comment"># Raw字符串，不会进行转义，抑制转义</span></span><br><span class="line">S = <span class="string">b&#x27;Spam&#x27;</span>              <span class="comment"># Python3中的字节字符串</span></span><br><span class="line">S = <span class="string">u&#x27;spam&#x27;</span>              <span class="comment"># Python2.6中的Unicode字符串</span></span><br><span class="line">s1+s2, s1*<span class="number">3</span>, s[i], s[i:j], <span class="built_in">len</span>(s)    <span class="comment"># 字符串操作</span></span><br><span class="line"><span class="string">&#x27;a %s parrot&#x27;</span> % <span class="string">&#x27;kind&#x27;</span>               <span class="comment"># 字符串格式化表达式</span></span><br><span class="line"><span class="string">&#x27;a &#123;0&#125; parrot&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;kind&#x27;</span>)        <span class="comment"># 字符串格式化方法</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> s: <span class="built_in">print</span>(x)                 <span class="comment"># 字符串迭代，成员关系</span></span><br><span class="line">[x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> s]                     <span class="comment"># 字符串列表解析</span></span><br><span class="line"><span class="string">&#x27;,&#x27;</span>.join([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])        <span class="comment"># 字符串输出，结果：a,b,c</span></span><br></pre></td></tr></table></figure>

<p>#– 内置str处理函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;stringobject&quot;</span></span><br><span class="line">str1.upper(); str1.lower(); str1.swapcase(); str1.capitalize(); str1.title()        <span class="comment"># 全部大写，全部小写、大小写转换，首字母大写，每个单词的首字母都大写</span></span><br><span class="line">str1.ljust(width)                       <span class="comment"># 获取固定长度，左对齐，右边不够用空格补齐</span></span><br><span class="line">str1.rjust(width)                       <span class="comment"># 获取固定长度，右对齐，左边不够用空格补齐</span></span><br><span class="line">str1.center(width)                      <span class="comment"># 获取固定长度，中间对齐，两边不够用空格补齐</span></span><br><span class="line">str1.zfill(width)                       <span class="comment"># 获取固定长度，右对齐，左边不足用0补齐</span></span><br><span class="line">str1.find(<span class="string">&#x27;t&#x27;</span>,start,end)                <span class="comment"># 查找字符串，可以指定起始及结束位置搜索</span></span><br><span class="line">str1.rfind(<span class="string">&#x27;t&#x27;</span>)                         <span class="comment"># 从右边开始查找字符串</span></span><br><span class="line">str1.count(<span class="string">&#x27;t&#x27;</span>)                         <span class="comment"># 查找字符串出现的次数</span></span><br><span class="line">    <span class="comment">#上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回-1</span></span><br><span class="line">str1.replace(<span class="string">&#x27;old&#x27;</span>,<span class="string">&#x27;new&#x27;</span>)               <span class="comment"># 替换函数，替换old为new，参数中可以指定maxReplaceTimes，即替换指定次数的old为new</span></span><br><span class="line">str1.strip(); str1.lstrip(); str1.rstrip(); str1.strip(<span class="string">&#x27;d&#x27;</span>); str1.lstrip(<span class="string">&#x27;d&#x27;</span>); str1.rstrip(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">str1.startswith(<span class="string">&#x27;start&#x27;</span>)                <span class="comment"># 是否以start开头</span></span><br><span class="line">str1.endswith(<span class="string">&#x27;end&#x27;</span>)                    <span class="comment"># 是否以end结尾</span></span><br><span class="line">str1.isalnum(); str1.isalpha(); str1.isdigit(); str1.islower(); str1.isupper()      <span class="comment"># 判断字符串是否全为字符、数字、大写、小写</span></span><br></pre></td></tr></table></figure>

<p>#– 三重引号编写多行字符串块，并且在代码折行处嵌入换行字符\n<br>​    mantra &#x3D; “””hello world<br>​            hello python<br>​            hello my friend”””<br>​    # mantra为”””hello world \n hello python \n hello my friend”””<br>​<br>#– 索引和分片：<br>​    S[0], S[len(S)–1], S[-1]                   # 索引<br>​    S[1:3], S[1:], S[:-1], S[1:10:2]        # 分片，第三个参数指定步长</p>
<p>#– 字符串转换工具：<br>​    int(‘42’), str(42)                      # 返回(42, ‘42’)<br>​    float(‘4.13’), str(4.13)                # 返回(4.13, ‘4.13’)<br>​    ord(‘s’), chr(115)                      # 返回(115, ‘s’)<br>​    int(‘1001’, 2)                          # 将字符串作为二进制数字，转化为数字，返回9<br>​    bin(13), oct(13), hex(13)               # 将整数转化为二进制&#x2F;八进制&#x2F;十六进制字符串，返回(‘1001’, ‘0o15’, ‘0xd’)<br>​<br>#– 另类字符串连接<br>​    name &#x3D; “wang” “hong”                    # 单行，name &#x3D; “wanghong”<br>​    name &#x3D; “wang” <br>​            “hong”                          # 多行，name &#x3D; “wanghong”</p>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>#– Python中的字符串格式化实现1–字符串格式化表达式<br>​    “””<br>​    基于C语言的’print’模型，并且在大多数的现有的语言中使用。<br>​    通用结构：%[(name)][flag][width].[precision]typecode<br>​    “””<br>​    “this is %d %s bird” % (1, ‘dead’)                          # 一般的格式化表达式<br>​    “%s—%s—%s” % (42, 3.14, [1, 2, 3])                      # 字符串输出：’42—3.14—[1, 2, 3]’<br>​    “%d…%6d…%-6d…%06d” % (1234, 1234, 1234, 1234)         #– 对齐方式及填充：”1234…  1234…1234  …001234”<br>​    x &#x3D; 1.23456789<br>​    “%e | %f | %g” % (x, x, x)                                  # 对齐方式：”1.234568e+00 | 1.234568 | 1.23457”<br>​    “%6.2f*%-6.2f*%06.2f*%+6.2f” % (x, x, x, x)                 # 对齐方式：’  1.23*1.23  <em>001.23</em> +1.23’<br>​    “%(name1)d—%(name2)s” % {“name1”:23, “name2”:”value2”}    # 基于字典的格式化表达式<br>​    “%(name)s is %(age)d” % vars()                              # vars()函数调用返回一个字典，包含了所有本函数调用时存在的变量<br>​<br>#– Python中的字符串格式化实现2–字符串格式化调用方法<br>​    # 普通调用<br>​    “{0}, {1} and {2}”.format(‘spam’, ‘ham’, ‘eggs’)            # 基于位置的调用<br>​    “{motto} and {pork}”.format(motto &#x3D; ‘spam’, pork &#x3D; ‘ham’)   # 基于Key的调用<br>​    “{motto} and {0}”.format(‘ham’, motto &#x3D; ‘spam’)             # 混合调用<br>​    # 添加键 属性 偏移量 (import sys)<br>​    “my {1[spam]} runs {0.platform}”.format(sys, {‘spam’:’laptop’})                 # 基于位置的键和属性<br>​    “{config[spam]} {sys.platform}”.format(sys &#x3D; sys, config &#x3D; {‘spam’:’laptop’})   # 基于Key的键和属性<br>​    “first &#x3D; {0[0]}, second &#x3D; {0[1]}”.format([‘A’, ‘B’, ‘C’])                       # 基于位置的偏移量<br>​    # 具体格式化<br>​    “{0:e}, {1:.3e}, {2:g}”.format(3.14159, 3.14159, 3.14159)   # 输出’3.141590e+00, 3.142e+00, 3.14159’<br>​    “{fieldname:format_spec}”.format(……)<br>​    # 说明:<br>​    “””<br>​        fieldname是指定参数的一个数字或关键字, 后边可跟可选的”.name”或”[index]”成分引用<br>​        format_spec ::&#x3D;  [[fill]align][sign][#][0][width][,][.precision][type]<br>​        fill        ::&#x3D;  <any character>              #填充字符<br>​        align       ::&#x3D;  “&lt;” | “&gt;” | “&#x3D;” | “^”        #对齐方式<br>​        sign        ::&#x3D;  “+” | “-“ | “ “              #符号说明<br>​        width       ::&#x3D;  integer                      #字符串宽度<br>​        precision   ::&#x3D;  integer                      #浮点数精度<br>​        type        ::&#x3D;  “b” | “c” | “d” | “e” | “E” | “f” | “F” | “g” | “G” | “n” | “o” | “s” | “x” | “X” | “%”<br>​    “””<br> 例子:<br>​        ‘&#x3D;{0:10} &#x3D; {1:10}’.format(‘spam’, 123.456)    # 输出’&#x3D;spam       &#x3D;    123.456’<br>​        ‘&#x3D;{0:&gt;10}&#x3D;’.format(‘test’)                    # 输出’&#x3D;      test&#x3D;’<br>​        ‘&#x3D;{0:&lt;10}&#x3D;’.format(‘test’)                    # 输出’&#x3D;test      &#x3D;’<br>​        ‘&#x3D;{0:^10}&#x3D;’.format(‘test’)                    # 输出’&#x3D;   test   &#x3D;’<br>​        ‘{0:X}, {1:o}, {2:b}’.format(255, 255, 255)   # 输出’FF, 377, 11111111’<br>​        ‘My name is {0:{1}}.’.format(‘Fred’, 8)       # 输出’My name is Fred    .’  动态指定参数​    </p>
<h1 id="9-文件操作"><a href="#9-文件操作" class="headerlink" title="9.文件操作"></a>9.文件操作</h1><p>#– 文件基本操作<br>​    output &#x3D; open(r’C:\spam’, ‘w’)          # 打开输出文件，用于写<br>​    input &#x3D; open(‘data’, ‘r’)               # 打开输入文件，用于读。打开的方式可以为’w’, ‘r’, ‘a’, ‘wb’, ‘rb’, ‘ab’等<br>​    fp.read([size])                         # size为读取的长度，以byte为单位<br>​    fp.readline([size])                     # 读一行，如果定义了size，有可能返回的只是一行的一部分<br>​    fp.readlines([size])                    # 把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长。<br>​    fp.readable()                           # 是否可读<br>​    fp.write(str)                           # 把str写到文件中，write()并不会在str后加上一个换行符<br>​    fp.writelines(seq)                      # 把seq的内容全部写到文件中(多行一次性写入)<br>​    fp.writeable()                          # 是否可写<br>​    fp.close()                              # 关闭文件。<br>​    fp.flush()                              # 把缓冲区的内容写入硬盘<br>​    fp.fileno()                             # 返回一个长整型的”文件标签“<br>​    fp.isatty()                             # 文件是否是一个终端设备文件（unix系统中的）<br>​    fp.tell()                               # 返回文件操作标记的当前位置，以文件的开头为原点<br>​    fp.next()                               # 返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。<br>​    fp.seek(offset[,whence])                # 将文件打操作标记移到offset的位置。whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。<br>​    fp.seekable()                           # 是否可以seek<br>​    fp.truncate([size])                     # 把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。<br>​    for line in open(‘data’):<br>​        print(line)                         # 使用for语句，比较适用于打开比较大的文件<br>​    open(‘f.txt’, encoding &#x3D; ‘latin-1’)     # Python3.x Unicode文本文件<br>​    open(‘f.bin’, ‘rb’)                     # Python3.x 二进制bytes文件<br>​    # 文件对象还有相应的属性：buffer closed encoding errors line_buffering name newlines等<br>​<br>#– 其他<br>​    # Python中的真假值含义：1. 数字如果非零，则为真，0为假。 2. 其他对象如果非空，则为真<br>​    # 通常意义下的类型分类：1. 数字、序列、映射。 2. 可变类型和不可变类型</p>
<p>“””语法和语句—-语法和语句—-语法和语句—-语法和语句—-语法和语句—-语法和语句—-语法和语句—-语法和语句—-语法和语句—-语法和语句—-语法和语句”””</p>
<p>#– 赋值语句的形式<br>​    spam &#x3D; ‘spam’                          # 基本形式<br>​    spam, ham &#x3D; ‘spam’, ‘ham’              # 元组赋值形式<br>​    [spam, ham] &#x3D; [‘s’, ‘h’]               # 列表赋值形式<br>​    a, b, c, d &#x3D; ‘abcd’                    # 序列赋值形式<br>​    a, *b, c &#x3D; ‘spam’                      # 序列解包形式（Python3.x中才有）<br>​    spam &#x3D; ham &#x3D; ‘no’                      # 多目标赋值运算，涉及到共享引用<br>​    spam +&#x3D; 42                             # 增强赋值，涉及到共享引用</p>
<p>#– 序列赋值 序列解包<br>​    [a, b, c] &#x3D; (1, 2, 3)                  # a &#x3D; 1, b &#x3D; 2, c &#x3D; 3<br>​    a, b, c, d &#x3D; “spam”                    # a &#x3D; ‘s’, b &#x3D; ‘p’<br>​    a, b, c &#x3D; range(3)                     # a &#x3D; 0, b &#x3D; 1<br>​    a, *b &#x3D; [1, 2, 3, 4]                   # a &#x3D; 1, b &#x3D; [2, 3, 4]<br>​    <em>a, b &#x3D; [1, 2, 3, 4]                   # a &#x3D; [1, 2, 3], b &#x3D; 4<br>​    a, <em>b, c &#x3D; [1, 2, 3, 4]                # a &#x3D; 1, b &#x3D; [2, 3], c &#x3D; 4<br>​    # 带有</em>时 会优先匹配</em>之外的变量 如<br>​    a, *b, c &#x3D; [1, 2]                      # a &#x3D; 1, c &#x3D; 2, b &#x3D; []</p>
<p>#– print函数原型<br>​    print(value, …, sep&#x3D;’ ‘, end&#x3D;’\n’, file&#x3D;sys.stdout, flush&#x3D;False)<br>​    # 流的重定向<br>​    print(‘hello world’)                   # 等于sys.stdout.write(‘hello world’)<br>​    temp &#x3D; sys.stdout                      # 原有流的保存<br>​    sys.stdout &#x3D; open(‘log.log’, ‘a’)      # 流的重定向<br>​    print(‘hello world’)                   # 写入到文件log.log<br>​    sys.stdout.close()<br>​    sys.stdout &#x3D; temp                      # 原有流的复原<br>​<br>#– Python中and或or总是返回对象(左边的对象或右边的对象) 且具有短路求值的特性<br>​    1 or 2 or 3                            # 返回 1<br>​    1 and 2 and 3                          # 返回 3</p>
<p>#– if&#x2F;else三元表达符（if语句在行内）<br>​    A &#x3D; 1 if X else 2<br>​    A &#x3D; 1 if X else (2 if Y else 3)<br>​    # 也可以使用and-or语句（一条语句实现多个if-else）<br>​    result &#x3D; (a &gt; 20 and “big than 20” or a &gt; 10 and “big than 10” or a &gt; 5 and “big than 5”)</p>
<p>#– Python的while语句或者for语句可以带else语句 当然也可以带continue&#x2F;break&#x2F;pass语句<br>​    while a &gt; 1:<br>​        anything<br>​    else:<br>​        anything<br>​    # else语句会在循环结束后执行，除非在循环中执行了break，同样的还有for语句<br>​    for i in range(5):<br>​        anything<br>​    else:<br>​        anything</p>
<p>#– for循环的元组赋值<br>​    for (a, b) in [(1, 2), (3, 4)]:                   # 最简单的赋值<br>​    for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]:    # 自动解包赋值<br>​    for ((a, b), c) in [((1, 2), 3), (“XY”, 6)]:      # 自动解包 a &#x3D; X, b &#x3D; Y, c &#x3D; 6<br>​    for (a, *b) in [(1, 2, 3), (4, 5, 6)]:            # 自动解包赋值</p>
<p>#– 列表解析语法<br>​    M &#x3D; [[1,2,3], [4,5,6], [7,8,9]]<br>​    res &#x3D; [sum(row) for row in M]                     # G &#x3D; [6, 15, 24] 一般的列表解析 生成一个列表<br>​    res &#x3D; [c * 2 for c in ‘spam’]                     # [‘ss’, ‘pp’, ‘aa’, ‘mm’]<br>​    res &#x3D; [a * b for a in [1, 2] for b in [4, 5]]     # 多解析过程 返回[4, 5, 8, 10]<br>​    res &#x3D; [a for a in [1, 2, 3] if a &lt; 2]             # 带判断条件的解析过程<br>​    res &#x3D; [a if a &gt; 0 else 0 for a in [-1, 0, 1]]     # 带判断条件的高级解析过程<br>​    # 两个列表同时解析：使用zip函数<br>​    for teama, teamb in zip([“Packers”, “49ers”], [“Ravens”, “Patriots”]):<br>​        print(teama + “ vs. “ + teamb)<br>​    # 带索引的列表解析：使用enumerate函数<br>​    for index, team in enumerate([“Packers”, “49ers”, “Ravens”, “Patriots”]):<br>​        print(index, team)                            # 输出0, Packers \n 1, 49ers \n ……<br>​<br>#– 生成器表达式<br>​    G &#x3D; (sum(row) for row in M)                       # 使用小括号可以创建所需结果的生成器generator object<br>​    next(G), next(G), next(G)                         # 输出(6, 15, 24)<br>​    G &#x3D; {sum(row) for row in M}                       # G &#x3D; {6, 15, 24} 解析语法还可以生成集合和字典<br>​    G &#x3D; {i:sum(M[i]) for i in range(3)}               # G &#x3D; {0: 6, 1: 15, 2: 24}</p>
<p>#– 文档字符串:出现在Module的开端以及其中函数或类的开端 使用三重引号字符串<br>​    “””<br>​    module document<br>​    “””<br>​    def func():<br>​        “””<br>​        function document<br>​        “””<br>​        print()<br>​    class Employee:<br>​        “””<br>​        class document<br>​        “””<br>​        print()<br>​    print(func.<strong>doc</strong>)                # 输出函数文档字符串<br>​    print(Employee.<strong>doc</strong>)            # 输出类的文档字符串<br>​<br>#– 命名惯例:<br>​    “””<br>​    以单一下划线开头的变量名(_X)不会被from module import*等语句导入<br>​    前后有两个下划线的变量名(<strong>X</strong>)是系统定义的变量名，对解释器有特殊意义<br>​    以两个下划线开头但不以下划线结尾的变量名(__X)是类的本地(私有)变量<br>​    “””</p>
<p>#– 列表解析 in成员关系测试 map sorted zip enumerate内置函数等都使用了迭代协议<br>​    ‘first line’ in open(‘test.txt’)   # in测试 返回True或False<br>​    list(map(str.upper, open(‘t’)))    # map内置函数<br>​    sorted(iter([2, 5, 8, 3, 1]))      # sorted内置函数<br>​    list(zip([1, 2], [3, 4]))          # zip内置函数 [(1, 3), (2, 4)]</p>
<p>#– del语句: 手动删除某个变量<br>​    del X</p>
<p>#– 获取列表的子表的方法:<br>​    x &#x3D; [1,2,3,4,5,6]<br>​    x[:3]                              # 前3个[1,2,3]<br>​    x[1:5]                             # 中间4个[2,3,4,5]<br>​    x[-3:]                             # 最后3个[4,5,6]<br>​    x[::2]                             # 奇数项[1,3,5]<br>​    x[1::2]                            # 偶数项[2,4,6]<br>​<br>#– 手动迭代：iter和next<br>​    L &#x3D; [1, 2]<br>​    I &#x3D; iter(L)                        # I为L的迭代器<br>​    I.next()                           # 返回1<br>​    I.next()                           # 返回2<br>​    I.next()                           # Error:StopIteration<br>​<br>#– Python中的可迭代对象<br>​    “””<br>​    1.range迭代器<br>​    2.map、zip和filter迭代器<br>​    3.字典视图迭代器：D.keys()), D.items()等<br>​    4.文件类型<br>​    “””</p>
<h1 id="10-函数"><a href="#10-函数" class="headerlink" title="10.函数"></a>10.函数</h1><p>“””函数语法规则—-函数语法规则—-函数语法规则—-函数语法规则—-函数语法规则—-函数语法规则—-函数语法规则—-函数语法规则—-函数语法规则—-函数语法规则”””</p>
<p>#– 函数相关的语句和表达式<br>​    myfunc(‘spam’)                     # 函数调用<br>​    def myfunc():                      # 函数定义<br>​    return None                        # 函数返回值<br>​    global a                           # 全局变量<br>​    nonlocal x                         # 在函数或其他作用域中使用外层（非全局）变量<br>​    yield x                            # 生成器函数返回<br>​    lambda                             # 匿名函数<br>​<br>#– Python函数变量名解析:LEGB原则，即:<br>​    “””<br>​    local(functin) –&gt; encloseing function locals –&gt; global(module) –&gt; build-in(python)<br>​    说明:以下边的函数maker为例 则相对于action而言 X为Local N为Encloseing<br>​    “””</p>
<p>#– 嵌套函数举例:工厂函数<br>​    def maker(N):<br>​        def action(X):<br>​            return X ** N<br>​        return action<br>​    f &#x3D; maker(2)                       # pass 2 to N<br>​    f(3)                               # 9, pass 3 to X</p>
<p>#– 嵌套函数举例:lambda实例<br>​    def maker(N):<br>​        action &#x3D; (lambda X: X**N)<br>​        return action<br>​    f &#x3D; maker(2)                       # pass 2 to N<br>​    f(3)                               # 9, pass 3 to X</p>
<p>#– nonlocal和global语句的区别<br>​    # nonlocal应用于一个嵌套的函数的作用域中的一个名称 例如:<br>​    start &#x3D; 100<br>​    def tester(start):<br>​        def nested(label):<br>​            nonlocal start             # 指定start为tester函数内的local变量 而不是global变量start<br>​            print(label, start)<br>​            start +&#x3D; 3<br>​        return nested<br>​    # global为全局的变量 即def之外的变量<br>​    def tester(start):<br>​        def nested(label):<br>​            global start               # 指定start为global变量start<br>​            print(label, start)<br>​            start +&#x3D; 3<br>​        return nested<br>​<br>#– 函数参数，不可变参数通过“值”传递，可变参数通过“引用”传递<br>​    def f(a, b, c): print(a, b, c)<br>​    f(1, 2, 3)                         # 参数位置匹配<br>​    f(1, c &#x3D; 3, b &#x3D; 2)                 # 参数关键字匹配<br>​    def f(a, b&#x3D;1, c&#x3D;2): print(a, b, c)<br>​    f(1)                               # 默认参数匹配<br>​    f(1, 2)                            # 默认参数匹配<br>​    f(a &#x3D; 1, c &#x3D; 3)                    # 关键字参数和默认参数的混合<br>​    # Keyword-Only参数:出现在*args之后 必须用关键字进行匹配<br>​    def keyOnly(a, *b, c): print(‘’)   # c就为keyword-only匹配 必须使用关键字c &#x3D; value匹配<br>​    def keyOnly(a, *, b, c): ……    # b c为keyword-only匹配 必须使用关键字匹配<br>​    def keyOnly(a, *, b &#x3D; 1): ……   # b有默认值 或者省略 或者使用关键字参数b &#x3D; value</p>
<p>#– 可变参数匹配: * 和 **<br>​    def f(*args): print(args)          # 在元组中收集不匹配的位置参数<br>​    f(1, 2, 3)                         # 输出(1, 2, 3)<br>​    def f(**args): print(args)         # 在字典中收集不匹配的关键字参数<br>​    f(a &#x3D; 1, b &#x3D; 2)                    # 输出{‘a’:1, ‘b’:2}<br>​    def f(a, *b, **c): print(a, b, c)  # 两者混合使用<br>​    f(1, 2, 3, x&#x3D;4, y&#x3D;5)               # 输出1, (2, 3), {‘x’:4, ‘y’:5}<br>​<br>#– 函数调用时的参数解包: * 和 ** 分别解包元组和字典<br>​    func(1, *(2, 3))  &lt;&#x3D;&#x3D;&gt;  func(1, 2, 3)<br>​    func(1, **{‘c’:3, ‘b’:2})  &lt;&#x3D;&#x3D;&gt;  func(1, b &#x3D; 2, c &#x3D; 3)<br>​    func(1, *(2, 3), **{‘c’:3, ‘b’:2})  &lt;&#x3D;&#x3D;&gt;  func(1, 2, 3, b &#x3D; 2, c &#x3D; 3)<br>​<br>#– 函数属性:(自己定义的)函数可以添加属性<br>​    def func():…..<br>​    func.count &#x3D; 1                     # 自定义函数添加属性<br>​    print.count &#x3D; 1                    # Error 内置函数不可以添加属性<br>​<br>#– 函数注解: 编写在def头部行 主要用于说明参数范围、参数类型、返回值类型等<br>​    def func(a:’spam’, b:(1, 10), c:float) -&gt; int :<br>​        print(a, b, c)<br>​    func.<strong>annotations</strong>               # {‘c’:&lt;class ‘float’&gt;, ‘b’:(1, 10), ‘a’:’spam’, ‘return’:&lt;class ‘int’&gt;}<br>​    # 编写注解的同时 还是可以使用函数默认值 并且注解的位置位于&#x3D;号的前边<br>​    def func(a:’spam’&#x3D;’a’, b:(1, 10)&#x3D;2, c:float&#x3D;3) -&gt; int :<br>​        print(a, b, c)</p>
<p>#– 匿名函数:lambda<br>​    f &#x3D; lambda x, y, z : x + y + z     # 普通匿名函数，使用方法f(1, 2, 3)<br>​    f &#x3D; lambda x &#x3D; 1, y &#x3D; 1: x + y     # 带默认参数的lambda函数<br>​    def action(x):                     # 嵌套lambda函数<br>​        return (lambda y : x + y)<br>​    f &#x3D; lambda: a if xxx() else b      # 无参数的lambda函数，使用方法f()</p>
<p>#– lambda函数与map filter reduce函数的结合<br>​    list(map((lambda x: x + 1), [1, 2, 3]))              # [2, 3, 4]<br>​    list(filter((lambda x: x &gt; 0), range(-4, 5)))        # [1, 2, 3, 4]<br>​    functools.reduce((lambda x, y: x + y), [1, 2, 3])    # 6<br>​    functools.reduce((lambda x, y: x * y), [2, 3, 4])    # 24<br>​<br>#– 生成器函数:yield VS return<br>​    def gensquare(N):<br>​        for i in range(N):<br>​            yield i** 2                # 状态挂起 可以恢复到此时的状态<br>​    for i in gensquare(5):             # 使用方法<br>​        print(i, end &#x3D; ‘ ‘)            # [0, 1, 4, 9, 16]<br>​    x &#x3D; gensquare(2)                   # x是一个生成对象<br>​    next(x)                            # 等同于x.<strong>next</strong>() 返回0<br>​    next(x)                            # 等同于x.<strong>next</strong>() 返回1<br>​    next(x)                            # 等同于x.<strong>next</strong>() 抛出异常StopIteration<br>​<br>#– 生成器表达式:小括号进行列表解析<br>​    G &#x3D; (x ** 2 for x in range(3))     # 使用小括号可以创建所需结果的生成器generator object<br>​    next(G), next(G), next(G)          # 和上述中的生成器函数的返回值一致<br>​    #（1）生成器(生成器函数&#x2F;生成器表达式)是单个迭代对象<br>​    G &#x3D; (x ** 2 for x in range(4))<br>​    I1 &#x3D; iter(G)                       # 这里实际上iter(G) &#x3D; G<br>​    next(I1)                           # 输出0<br>​    next(G)                            # 输出1<br>​    next(I1)                           # 输出4<br>​    #（2）生成器不保留迭代后的结果<br>​    gen &#x3D; (i for i in range(4))<br>​    2 in gen                           # 返回True<br>​    3 in gen                           # 返回True<br>​    1 in gen                           # 返回False，其实检测2的时候，1已经就不在生成器中了，即1已经被迭代过了，同理2、3也不在了</p>
<p>#– 本地变量是静态检测的<br>​    X &#x3D; 22                             # 全局变量X的声明和定义<br>​    def test():<br>​        print(X)                       # 如果没有下一语句 则该句合法 打印全局变量X<br>​        X &#x3D; 88                         # 这一语句使得上一语句非法 因为它使得X变成了本地变量 上一句变成了打印一个未定义的本地变量(局部变量)<br>​        if False:                      # 即使这样的语句 也会把print语句视为非法语句 因为:<br>​            X &#x3D; 88                     # Python会无视if语句而仍然声明了局部变量X<br>​    def test():                        # 改进<br>​        global X                       # 声明变量X为全局变量<br>​        print(X)                       # 打印全局变量X<br>​        X &#x3D; 88                         # 改变全局变量X<br>​<br>#– 函数的默认值是在函数定义的时候实例化的 而不是在调用的时候 例子:<br>​    def foo(numbers&#x3D;[]):               # 这里的[]是可变的<br>​        numbers.append(9)<br>​        print(numbers)<br>​    foo()                              # first time, like before, [9]<br>​    foo()                              # second time, not like before, [9, 9]<br>​    foo()                              # third time, not like before too, [9, 9, 9]<br>​    # 改进:<br>​    def foo(numbers&#x3D;None):<br>​        if numbers is None: numbers &#x3D; []<br>​        numbers.append(9)<br>​        print(numbers)<br>​    # 另外一个例子 参数的默认值为不可变的:<br>​    def foo(count&#x3D;0):                  # 这里的0是数字, 是不可变的<br>​        count +&#x3D; 1<br>​        print(count)<br>​    foo()                              # 输出1<br>​    foo()                              # 还是输出1<br>​    foo(3)                             # 输出4<br>​    foo()                              # 还是输出1<br>​    </p>
<h2 id="函数例子"><a href="#函数例子" class="headerlink" title="函数例子"></a>函数例子</h2><p>“””函数例子—-函数例子—-函数例子—-函数例子—-函数例子—-函数例子—-函数例子—-函数例子—-函数例子—-函数例子—-函数例子—-函数例子—-函数例子”””</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;数学运算类&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">abs</span>(x)                              <span class="comment"># 求绝对值，参数可以是整型，也可以是复数，若参数是复数，则返回复数的模</span></span><br><span class="line"><span class="built_in">complex</span>([real[, imag]])             <span class="comment"># 创建一个复数</span></span><br><span class="line"><span class="built_in">divmod</span>(a, b)                        <span class="comment"># 分别取商和余数，注意：整型、浮点型都可以</span></span><br><span class="line"><span class="built_in">float</span>([x])                          <span class="comment"># 将一个字符串或数转换为浮点数。如果无参数将返回0.0</span></span><br><span class="line"><span class="built_in">int</span>([x[, base]])                    <span class="comment"># 将一个字符串或浮点数转换为int类型，base表示进制</span></span><br><span class="line">long([x[, base]])                   <span class="comment"># 将一个字符串或浮点数转换为long类型</span></span><br><span class="line"><span class="built_in">pow</span>(x, y)                           <span class="comment"># 返回x的y次幂</span></span><br><span class="line"><span class="built_in">range</span>([start], stop[, step])        <span class="comment"># 产生一个序列，默认从0开始</span></span><br><span class="line"><span class="built_in">round</span>(x[, n])                       <span class="comment"># 四舍五入</span></span><br><span class="line"><span class="built_in">sum</span>(iterable[, start])              <span class="comment"># 对集合求和</span></span><br><span class="line"><span class="built_in">oct</span>(x)                              <span class="comment"># 将一个数字转化为8进制字符串</span></span><br><span class="line"><span class="built_in">hex</span>(x)                              <span class="comment"># 将一个数字转换为16进制字符串</span></span><br><span class="line"><span class="built_in">chr</span>(i)                              <span class="comment"># 返回给定int类型对应的ASCII字符</span></span><br><span class="line">unichr(i)                           <span class="comment"># 返回给定int类型的unicode</span></span><br><span class="line"><span class="built_in">ord</span>(c)                              <span class="comment"># 返回ASCII字符对应的整数</span></span><br><span class="line"><span class="built_in">bin</span>(x)                              <span class="comment"># 将整数x转换为二进制字符串</span></span><br><span class="line"><span class="built_in">bool</span>([x])                           <span class="comment"># 将x转换为Boolean类型</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;集合类操作&quot;&quot;&quot;</span></span><br><span class="line">basestring()                        <span class="comment"># str和unicode的超类，不能直接调用，可以用作isinstance判断</span></span><br><span class="line"><span class="built_in">format</span>(value [, format_spec])       <span class="comment"># 格式化输出字符串，格式化的参数顺序从0开始，如“I am &#123;0&#125;,I like &#123;1&#125;”</span></span><br><span class="line"><span class="built_in">enumerate</span>(sequence[, start=<span class="number">0</span>])      <span class="comment"># 返回一个可枚举的对象，注意它有第二个参数</span></span><br><span class="line"><span class="built_in">iter</span>(obj[, sentinel])               <span class="comment"># 生成一个对象的迭代器，第二个参数表示分隔符</span></span><br><span class="line"><span class="built_in">max</span>(iterable[, args...][key])       <span class="comment"># 返回集合中的最大值</span></span><br><span class="line"><span class="built_in">min</span>(iterable[, args...][key])       <span class="comment"># 返回集合中的最小值</span></span><br><span class="line"><span class="built_in">dict</span>([arg])                         <span class="comment"># 创建数据字典</span></span><br><span class="line"><span class="built_in">list</span>([iterable])                    <span class="comment"># 将一个集合类转换为另外一个集合类</span></span><br><span class="line"><span class="built_in">set</span>()                               <span class="comment"># set对象实例化</span></span><br><span class="line"><span class="built_in">frozenset</span>([iterable])               <span class="comment"># 产生一个不可变的set</span></span><br><span class="line"><span class="built_in">tuple</span>([iterable])                   <span class="comment"># 生成一个tuple类型</span></span><br><span class="line"><span class="built_in">str</span>([<span class="built_in">object</span>])                       <span class="comment"># 转换为string类型</span></span><br><span class="line"><span class="built_in">sorted</span>(iterable[, cmp[, key[, reverse]]])             <span class="comment"># 集合排序</span></span><br><span class="line">    L = [(<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>),(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>),(<span class="string">&#x27;d&#x27;</span>,<span class="number">4</span>)]</span><br><span class="line">    <span class="built_in">sorted</span>(L, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]), reverse=<span class="literal">True</span>)      <span class="comment"># 使用Key参数和reverse参数</span></span><br><span class="line">    <span class="built_in">sorted</span>(L, key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>]))             <span class="comment"># 使用key参数进行多条件排序，即如果x[0]相同，则比较x[1]</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;逻辑判断&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">all</span>(iterable)                       <span class="comment"># 集合中的元素都为真的时候为真，特别的，若为空串返回为True</span></span><br><span class="line"><span class="built_in">any</span>(iterable)                       <span class="comment"># 集合中的元素有一个为真的时候为真，特别的，若为空串返回为False</span></span><br><span class="line">cmp(x, y)                           <span class="comment"># 如果x &lt; y ,返回负数；x == y, 返回0；x &gt; y,返回正数</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;IO操作&quot;&quot;&quot;</span></span><br><span class="line">file(filename [, mode [, bufsize]]) <span class="comment"># file类型的构造函数。</span></span><br><span class="line"><span class="built_in">input</span>([prompt])                     <span class="comment"># 获取用户输入，推荐使用raw_input，因为该函数将不会捕获用户的错误输入</span></span><br><span class="line">raw_input([prompt])                 <span class="comment"># 设置输入，输入都是作为字符串处理</span></span><br><span class="line"><span class="built_in">open</span>(name[, mode[, buffering]])     <span class="comment"># 打开文件，与file有什么不同？推荐使用open</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;其他&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">callable</span>(<span class="built_in">object</span>)                    <span class="comment"># 检查对象object是否可调用</span></span><br><span class="line"><span class="built_in">classmethod</span>(func)                   <span class="comment"># 用来说明这个func是个类方法</span></span><br><span class="line"><span class="built_in">staticmethod</span>(func)                  <span class="comment"># 用来说明这个func为静态方法</span></span><br><span class="line"><span class="built_in">dir</span>([<span class="built_in">object</span>])                       <span class="comment"># 不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。</span></span><br><span class="line"><span class="built_in">help</span>(obj)                           <span class="comment"># 返回obj的帮助信息</span></span><br><span class="line"><span class="built_in">eval</span>(expression)                    <span class="comment"># 计算表达式expression的值，并返回</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="built_in">str</span>)                           <span class="comment"># 将str作为Python语句执行</span></span><br><span class="line">execfile(filename)                  <span class="comment"># 用法类似exec()，不同的是execfile的参数filename为文件名，而exec的参数为字符串。</span></span><br><span class="line"><span class="built_in">filter</span>(function, iterable)          <span class="comment"># 构造一个序列，等价于[item for item in iterable if function(item)]，function返回值为True或False的函数</span></span><br><span class="line">    <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="built_in">bool</span>, <span class="built_in">range</span>(-<span class="number">3</span>, <span class="number">4</span>)))<span class="comment"># 返回[-3, -2, -1, 1, 2, 3], 没有0</span></span><br><span class="line"><span class="built_in">hasattr</span>(<span class="built_in">object</span>, name)               <span class="comment"># 判断对象object是否包含名为name的特性</span></span><br><span class="line"><span class="built_in">getattr</span>(<span class="built_in">object</span>, name [, defalut])   <span class="comment"># 获取一个类的属性</span></span><br><span class="line"><span class="built_in">setattr</span>(<span class="built_in">object</span>, name, value)        <span class="comment"># 设置属性值</span></span><br><span class="line"><span class="built_in">delattr</span>(<span class="built_in">object</span>, name)               <span class="comment"># 删除object对象名为name的属性</span></span><br><span class="line"><span class="built_in">globals</span>()                           <span class="comment"># 返回一个描述当前全局符号表的字典</span></span><br><span class="line"><span class="built_in">hash</span>(<span class="built_in">object</span>)                        <span class="comment"># 如果对象object为哈希表类型，返回对象object的哈希值</span></span><br><span class="line"><span class="built_in">id</span>(<span class="built_in">object</span>)                          <span class="comment"># 返回对象的唯一标识，一串数字</span></span><br><span class="line"><span class="built_in">isinstance</span>(<span class="built_in">object</span>, classinfo)       <span class="comment"># 判断object是否是class的实例</span></span><br><span class="line">    <span class="built_in">isinstance</span>(<span class="number">1</span>, <span class="built_in">int</span>)              <span class="comment"># 判断是不是int类型</span></span><br><span class="line">    <span class="built_in">isinstance</span>(<span class="number">1</span>, (<span class="built_in">int</span>, <span class="built_in">float</span>))     <span class="comment"># isinstance的第二个参数接受一个元组类型</span></span><br><span class="line"><span class="built_in">issubclass</span>(<span class="keyword">class</span>, classinfo)        <span class="comment"># 判断class是否为classinfo的子类</span></span><br><span class="line"><span class="built_in">locals</span>()                            <span class="comment"># 返回当前的变量列表</span></span><br><span class="line"><span class="built_in">map</span>(function, iterable, ...)        <span class="comment"># 遍历每个元素，执行function操作</span></span><br><span class="line">    <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">abs</span>, <span class="built_in">range</span>(-<span class="number">3</span>, <span class="number">4</span>)))    <span class="comment"># 返回[3, 2, 1, 0, 1, 2, 3]</span></span><br><span class="line"><span class="built_in">next</span>(iterator[, default])           <span class="comment"># 类似于iterator.next()</span></span><br><span class="line"><span class="built_in">property</span>([fget[, fset[, fdel[, doc]]]])           <span class="comment"># 属性访问的包装类，设置后可以通过c.x=value等来访问setter和getter</span></span><br><span class="line">reduce(function, iterable[, initializer])         <span class="comment"># 合并操作，从第一个开始是前两个参数，然后是前两个的结果与第三个合并进行处理，以此类推</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):<span class="keyword">return</span> x + y </span><br><span class="line">    reduce(add, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))                     <span class="comment"># 返回55 (注:1+2+3+4+5+6+7+8+9+10 = 55)</span></span><br><span class="line">    reduce(add, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>), <span class="number">20</span>)                 <span class="comment"># 返回75</span></span><br><span class="line">reload(module)                      <span class="comment"># 重新加载模块</span></span><br><span class="line"><span class="built_in">repr</span>(<span class="built_in">object</span>)                        <span class="comment"># 将一个对象变幻为可打印的格式</span></span><br><span class="line"><span class="built_in">slice</span>(start, stop[, step])          <span class="comment"># 产生分片对象</span></span><br><span class="line"><span class="built_in">type</span>(<span class="built_in">object</span>)                        <span class="comment"># 返回该object的类型</span></span><br><span class="line"><span class="built_in">vars</span>([<span class="built_in">object</span>])                      <span class="comment"># 返回对象的变量名、变量值得字典</span></span><br><span class="line">    a = Class();                    <span class="comment"># Class为一个空类</span></span><br><span class="line">    a.name = <span class="string">&#x27;qi&#x27;</span>, a.age = <span class="number">9</span></span><br><span class="line">    <span class="built_in">vars</span>(a)                         <span class="comment"># &#123;&#x27;name&#x27;:&#x27;qi&#x27;, &#x27;age&#x27;:9&#125;</span></span><br><span class="line"><span class="built_in">zip</span>([iterable, ...])                <span class="comment"># 返回对应数组</span></span><br><span class="line">    <span class="built_in">list</span>(<span class="built_in">zip</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])) <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],  b = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]</span><br><span class="line">    z = <span class="built_in">zip</span>(a, b)                   <span class="comment"># 压缩：[(1, &quot;a&quot;), (2, &quot;b&quot;), (3, &quot;c&quot;)]</span></span><br><span class="line">    <span class="built_in">zip</span>(*z)                         <span class="comment"># 解压缩：[(1, 2, 3), (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)]</span></span><br><span class="line">unicode(string, encoding, errors)   <span class="comment"># 将字符串string转化为unicode形式，string为encoded string。</span></span><br></pre></td></tr></table></figure>

<h1 id="11-模块"><a href="#11-模块" class="headerlink" title="11.模块"></a>11.模块</h1><p>“””模块Moudle—-模块Moudle—-模块Moudle—-模块Moudle—-模块Moudle—-模块Moudle—-模块Moudle—-模块Moudle—-模块Moudle—-模块Moudle—-模块Moudle”””</p>
<p>#– Python模块搜索路径:<br>​    “””<br>​    (1)程序的主目录    (2)PYTHONPATH目录 (3)标准链接库目录 (4)任何.pth文件的内容<br>​    “””<br>​<br>#– 查看全部的模块搜索路径<br>​    import sys<br>​    sys.path<br>​<br>#– 模块的使用代码<br>​    import module1, module2             # 导入module1 使用module1.printer()<br>​    from module1 import printer         # 导入module1中的printer变量 使用printer()<br>​    from module1 imoprt *               # 导入module1中的全部变量 使用不必添加module1前缀</p>
<p>#– 重载模块reload: 这是一个内置函数 而不是一条语句<br>​    from imp import reload<br>​    reload(module)<br>​<br>#– 模块的包导入:使用点号(.)而不是路径(dir1\dir2)进行导入<br>​    import dir1.dir2.mod                # d导入包(目录)dir1中的包dir2中的mod模块 此时dir1必须在Python可搜索路径中<br>​    from dir1.dir2.mod import *         # from语法的包导入</p>
<p>#– <strong>init</strong>.py包文件:每个导入的包中都应该包含这么一个文件<br>​    “””<br>​    该文件可以为空<br>​    首次进行包导入时 该文件会自动执行<br>​    高级功能:在该文件中使用__all__列表来定义包(目录)以from<em>的形式导入时 需要导入什么<br>​    “””<br>​<br>#– 包相对导入:使用点号(.) 只能使用from语句<br>​    from . import spam                  # 导入当前目录下的spam模块（错误: 当前目录下的模块, 直接导入即可）<br>​    from .spam import name              # 导入当前目录下的spam模块的name属性（错误: 当前目录下的模块, 直接导入即可，不用加.）<br>​    from .. import spam                 # 导入当前目录的父目录下的spam模块<br>​<br>#– 包相对导入与普通导入的区别<br>​    from string import *                # 这里导入的string模块为sys.path路径上的 而不是本目录下的string模块(如果存在也不是)<br>​    from .string import *               # 这里导入的string模块为本目录下的(不存在则导入失败) 而不是sys.path路径上的<br>​<br>#– 模块数据隐藏:最小化from</em>的破坏<br>​    _X                                  # 变量名前加下划线可以防止from<em>导入时该变量名被复制出去<br>​    <strong>all</strong> &#x3D; [‘x’, ‘x1’, ‘x2’]         # 使用__all__列表指定from</em>时复制出去的变量名(变量名在列表中为字符串形式)</p>
<p>#– 可以使用__name__进行模块的单元测试:当模块为顶层执行文件时值为’<strong>main</strong>‘ 当模块被导入时为模块名<br>​    if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>​        doSomething<br>​    # 模块属性中还有其他属性，例如：<br>​    <strong>doc</strong>                             # 模块的说明文档<br>​    <strong>file</strong>                            # 模块文件的文件名，包括全路径<br>​    <strong>name</strong>                            # 主文件或者被导入文件<br>​    <strong>package</strong>                         # 模块所在的包<br>​<br>#– import语句from语句的as扩展<br>​    import modulename as name<br>​    from modulename import attrname as name<br>​<br>#– 得到模块属性的几种方法 假设为了得到name属性的值<br>​    M.name<br>​    M.<strong>dict</strong>[‘name’]<br>​    sys.modules[‘M’].name<br>​    getattr(M, ‘name’)</p>
<h1 id="12-类"><a href="#12-类" class="headerlink" title="12.类"></a>12.类</h1><p>“””类与面向对象—-类与面向对象—-类与面向对象—-类与面向对象—-类与面向对象—-类与面向对象—-类与面向对象—-类与面向对象—-类与面向对象—-类与面向对象”””</p>
<p>#– 最普通的类<br>​    class C1(C2, C3):<br>​        spam &#x3D; 42                       # 数据属性<br>​        def <strong>init</strong>(self, name):       # 函数属性:构造函数<br>​            self.name &#x3D; name<br>​        def <strong>del</strong>(self):              # 函数属性:析构函数<br>​            print(“goodbey “, self.name)<br>​    I1 &#x3D; C1(‘bob’)<br>​<br>#– Python的类没有基于参数的函数重载<br>​    class FirstClass:<br>​        def test(self, string):<br>​            print(string)<br>​        def test(self):                 # 此时类中只有一个test函数 即后者test(self) 它覆盖掉前者带参数的test函数<br>​            print(“hello world”)</p>
<p>#– 子类扩展超类: 尽量调用超类的方法<br>​    class Manager(Person):<br>​        def giveRaise(self, percent, bonus &#x3D; .10):<br>​            self.pay &#x3D; int(self.pay*(1 + percent + bonus))     # 不好的方式 复制粘贴超类代码<br>​            Person.giveRaise(self, percent + bonus)            # 好的方式 尽量调用超类方法</p>
<p>#– 类内省工具<br>​    bob &#x3D; Person(‘bob’)<br>​    bob.<strong>class</strong>                       # &lt;class ‘Person’&gt;<br>​    bob.<strong>class</strong>.<strong>name</strong>              # ‘Person’<br>​    bob.<strong>dict</strong>                        # {‘pay’:0, ‘name’:’bob’, ‘job’:’Manager’}<br>​<br>#– 返回1中 数据属性spam是属于类 而不是对象<br>​    I1 &#x3D; C1(‘bob’); I2 &#x3D; C2(‘tom’)      # 此时I1和I2的spam都为42 但是都是返回的C1的spam属性<br>​    C1.spam &#x3D; 24                        # 此时I1和I2的spam都为24<br>​    I1.spam &#x3D; 3                         # 此时I1新增自有属性spam 值为2 I2和C1的spam还都为24<br>​<br>#– 类方法调用的两种方式<br>​    instance.method(arg…)<br>​    class.method(instance, arg…)<br>​<br>#– 抽象超类的实现方法<br>​    # (1)某个函数中调用未定义的函数 子类中定义该函数<br>​        def delegate(self):<br>​            self.action()               # 本类中不定义action函数 所以使用delegate函数时就会出错<br>​    # (2)定义action函数 但是返回异常<br>​        def action(self):<br>​            raise NotImplementedError(“action must be defined”)<br>​    # (3)上述的两种方法还都可以定义实例对象 实际上可以利用@装饰器语法生成不能定义的抽象超类<br>​        from abc import ABCMeta, abstractmethod<br>​        class Super(metaclass &#x3D; ABCMeta):<br>​            @abstractmethod<br>​            def action(self): pass<br>​        x &#x3D; Super()                     # 返回 TypeError: Can’t instantiate abstract class Super with abstract methods action<br>​<br>#– # OOP和继承: “is-a”的关系<br>​    class A(B):<br>​        pass<br>​    a &#x3D; A()<br>​    isinstance(a, B)                    # 返回True, A是B的子类 a也是B的一种<br>​    # OOP和组合: “has-a”的关系<br>​    pass<br>​    # OOP和委托: “包装”对象 在Python中委托通常是以”<strong>getattr</strong>“钩子方法实现的, 这个方法会拦截对不存在属性的读取<br>​    # 包装类(或者称为代理类)可以使用__getattr__把任意读取转发给被包装的对象<br>​    class wrapper:<br>​        def <strong>init</strong>(self, object):<br>​            self.wrapped &#x3D; object<br>​        def __getattr(self, attrname):<br>​            print(‘Trace: ‘, attrname)<br>​            return getattr(self.wrapped, attrname)<br>​    # 注:这里使用getattr(X, N)内置函数以变量名字符串N从包装对象X中取出属性 类似于X.<strong>dict</strong>[N]<br>​    x &#x3D; wrapper([1, 2, 3])<br>​    x.append(4)                         # 返回 “Trace: append” [1, 2, 3, 4]<br>​    x &#x3D; wrapper({‘a’:1, ‘b’:2})<br>​    list(x.keys())                      # 返回 “Trace: keys” [‘a’, ‘b’]</p>
<p>#– 类的伪私有属性:使用__attr<br>​    class C1:<br>​        def <strong>init</strong>(self, name):<br>​            self.__name &#x3D; name          # 此时类的__name属性为伪私有属性 原理 它会自动变成self._C1__name &#x3D; name<br>​        def <strong>str</strong>(self):<br>​            return ‘self.name &#x3D; %s’ % self.__name<br>​    I &#x3D; C1(‘tom’)<br>​    print(I)                            # 返回 self.name &#x3D; tom<br>​    I.__name &#x3D; ‘jeey’                   # 这里无法访问 __name为伪私有属性<br>​    I._C1__name &#x3D; ‘jeey’                # 这里可以修改成功 self.name &#x3D; jeey<br>​<br>#– 类方法是对象:无绑定类方法对象 &#x2F; 绑定实例方法对象<br>​    class Spam:<br>​        def doit(self, message):<br>​            print(message)<br>​        def selfless(message)<br>​            print(message)<br>​    obj &#x3D; Spam()<br>​    x &#x3D; obj.doit                        # 类的绑定方法对象 实例 + 函数<br>​    x(‘hello world’)<br>​    x &#x3D; Spam.doit                       # 类的无绑定方法对象 类名 + 函数<br>​    x(obj, ‘hello world’)<br>​    x &#x3D; Spam.selfless                   # 类的无绑定方法是函数 在3.0之前无效<br>​    x(‘hello world’)</p>
<p>#– 获取对象信息: 属性和方法<br>​    a &#x3D; MyObject()<br>​    dir(a)                              # 使用dir函数<br>​    hasattr(a, ‘x’)                     # 测试是否有x属性或方法 即a.x是否已经存在<br>​    setattr(a, ‘y’, 19)                 # 设置属性或方法 等同于a.y &#x3D; 19<br>​    getattr(a, ‘z’, 0)                  # 获取属性或方法 如果属性不存在 则返回默认值0<br>​    #这里有个小技巧，setattr可以设置一个不能访问到的属性，即只能用getattr获取<br>​    setattr(a, “can’t touch”, 100)      # 这里的属性名带有空格，不能直接访问<br>​    getattr(a, “can’t touch”, 0)        # 但是可以用getattr获取</p>
<p>#– 为类动态绑定属性或方法: MethodType方法<br>​    # 一般创建了一个class的实例后, 可以给该实例绑定任何属性和方法, 这就是动态语言的灵活性<br>​    class Student(object):<br>​        pass<br>​    s &#x3D; Student()<br>​    s.name &#x3D; ‘Michael’                  # 动态给实例绑定一个属性<br>​    def set_age(self, age):             # 定义一个函数作为实例方法<br>​        self.age &#x3D; age<br>​    from types import MethodType<br>​    s.set_age &#x3D; MethodType(set_age, s)  # 给实例绑定一个方法 类的其他实例不受此影响<br>​    s.set_age(25)                       # 调用实例方法<br>​    Student.set_age &#x3D; MethodType(set_age, Student)    # 为类绑定一个方法 类的所有实例都拥有该方法</p>
<h2 id="类高级"><a href="#类高级" class="headerlink" title="类高级"></a>类高级</h2><p>“””类的高级话题—-类的高级话题—-类的高级话题—-类的高级话题—-类的高级话题—-类的高级话题—-类的高级话题—-类的高级话题—-类的高级话题—-类的高级话题”””<br>​<br>#– 多重继承: “混合类”, 搜索方式”从下到上 从左到右 广度优先”<br>​    class A(B, C):<br>​        pass</p>
<p>#– 类的继承和子类的初始化<br>​    # 1.子类定义了__init__方法时，若未显示调用基类__init__方法，python不会帮你调用。<br>​    # 2.子类未定义__init__方法时，python会自动帮你调用首个基类的__init__方法，注意是首个。<br>​    # 3.子类显示调用基类的初始化函数：<br>​    class FooParent(object):<br>​        def <strong>init</strong>(self, a):<br>​            self.parent &#x3D; ‘I&#39;m the Parent.’<br>​            print(‘Parent:a&#x3D;’ + str(a))<br>​        def bar(self, message):<br>​            print(message + ‘ from Parent’)<br>​    class FooChild(FooParent):<br>​        def <strong>init</strong>(self, a):<br>​            FooParent.<strong>init</strong>(self, a)<br>​            print(‘Child:a&#x3D;’ + str(a))<br>​        def bar(self, message):<br>​            FooParent.bar(self, message)<br>​            print(message + ‘ from Child’)<br>​    fooChild &#x3D; FooChild(10)<br>​    fooChild.bar(‘HelloWorld’)<br>​<br>#– #实例方法 &#x2F; 静态方法 &#x2F; 类方法<br>​    class Methods:<br>​        def imeth(self, x): print(self, x)      # 实例方法：传入的是实例和数据，操作的是实例的属性<br>​        def smeth(x): print(x)                  # 静态方法：只传入数据 不传入实例，操作的是类的属性而不是实例的属性<br>​        def cmeth(cls, x): print(cls, x)        # 类方法：传入的是类对象和数据<br>​        smeth &#x3D; staticmethod(smeth)             # 调用内置函数，也可以使用@staticmethod<br>​        cmeth &#x3D; classmethod(cmeth)              # 调用内置函数，也可以使用@classmethod<br>​    obj &#x3D; Methods()<br>​    obj.imeth(1)                                # 实例方法调用 &lt;__main__.Methods object…&gt; 1<br>​    Methods.imeth(obj, 2)                       # &lt;__main__.Methods object…&gt; 2<br>​    Methods.smeth(3)                            # 静态方法调用 3<br>​    obj.smeth(4)                                # 这里可以使用实例进行调用<br>​    Methods.cmeth(5)                            # 类方法调用 &lt;class ‘__main__.Methods’&gt; 5<br>​    obj.cmeth(6)                                # &lt;class ‘__main__.Methods’&gt; 6<br>​<br>#– 函数装饰器:是它后边的函数的运行时的声明 由@符号以及后边紧跟的”元函数”(metafunction)组成<br>​        @staticmethod<br>​        def smeth(x): print(x)<br>​    # 等同于:<br>​        def smeth(x): print(x)<br>​        smeth &#x3D; staticmethod(smeth)<br>​    # 同理<br>​        @classmethod<br>​        def cmeth(cls, x): print(x)<br>​    # 等同于<br>​        def cmeth(cls, x): print(x)<br>​        cmeth &#x3D; classmethod(cmeth)<br>​<br>#– 类修饰器:是它后边的类的运行时的声明 由@符号以及后边紧跟的”元函数”(metafunction)组成<br>​        def decorator(aClass):…..<br>​        @decorator<br>​        class C:….<br>​    # 等同于:<br>​        class C:….<br>​        C &#x3D; decorator(C)</p>
<p>#– 限制class属性: __slots__属性<br>​    class Student:<br>​        <strong>slots</strong> &#x3D; (‘name’, ‘age’)             # 限制Student及其实例只能拥有name和age属性<br>​    # __slots__属性只对当前类起作用, 对其子类不起作用<br>​    # __slots__属性能够节省内存<br>​    # __slots__属性可以为列表list，或者元组tuple<br>​<br>#– 类属性高级话题: @property<br>​    # 假设定义了一个类:C，该类必须继承自object类，有一私有变量_x<br>​    class C(object):<br>​        def <strong>init</strong>(self):<br>​            self.__x &#x3D; None<br>​    # 第一种使用属性的方法<br>​        def getx(self):<br>​            return self.__x<br>​        def setx(self, value):<br>​            self.__x &#x3D; value<br>​        def delx(self):<br>​            del self.__x<br>​        x &#x3D; property(getx, setx, delx, ‘’)<br>​    # property函数原型为property(fget&#x3D;None,fset&#x3D;None,fdel&#x3D;None,doc&#x3D;None)<br>​    # 使用<br>​    c &#x3D; C()<br>​    c.x &#x3D; 100                         # 自动调用setx方法<br>​    y &#x3D; c.x                           # 自动调用getx方法<br>​    del c.x                           # 自动调用delx方法<br>​    # 第二种方法使用属性的方法<br>​        @property<br>​        def x(self):<br>​            return self.__x<br>​        @x.setter<br>​        def x(self, value):<br>​           self.__x &#x3D; value<br>​        @x.deleter<br>​        def x(self):<br>​           del self.__x<br>​    # 使用<br>​    c &#x3D; C()<br>​    c.x &#x3D; 100                         # 自动调用setter方法<br>​    y &#x3D; c.x                           # 自动调用x方法<br>​    del c.x                           # 自动调用deleter方法<br>​<br>#– 定制类: 重写类的方法<br>​    # (1)__str__方法、__repr__方法: 定制类的输出字符串<br>​    # (2)__iter__方法、next方法: 定制类的可迭代性<br>​    class Fib(object):<br>​        def <strong>init</strong>(self):<br>​            self.a, self.b &#x3D; 0, 1     # 初始化两个计数器a，b<br>​        def <strong>iter</strong>(self):<br>​            return self               # 实例本身就是迭代对象，故返回自己<br>​        def next(self):<br>​            self.a, self.b &#x3D; self.b, self.a + self.b<br>​            if self.a &gt; 100000:       # 退出循环的条件<br>​                raise StopIteration()<br>​            return self.a             # 返回下一个值<br>​    for n in Fib():<br>​        print(n)                      # 使用<br>​    # (3)__getitem__方法、__setitem__方法: 定制类的下标操作[] 或者切片操作slice<br>​    class Indexer(object):<br>​        def <strong>init</strong>(self):<br>​            self.data &#x3D; {}<br>​        def <strong>getitem</strong>(self, n):             # 定义getitem方法<br>​            print(‘getitem:’, n)<br>​            return self.data[n]<br>​        def <strong>setitem</strong>(self, key, value):    # 定义setitem方法<br>​            print(‘setitem:key &#x3D; {0}, value &#x3D; {1}’.format(key, value))<br>​            self.data[key] &#x3D; value<br>​    test &#x3D; Indexer()<br>​    test[0] &#x3D; 1;   test[3] &#x3D; ‘3’              # 调用setitem方法<br>​    print(test[0])                            # 调用getitem方法<br>​    # (4)__getattr__方法: 定制类的属性操作<br>​    class Student(object):<br>​        def <strong>getattr</strong>(self, attr):          # 定义当获取类的属性时的返回值<br>​            if attr&#x3D;&#x3D;’age’:<br>​                return 25                     # 当获取age属性时返回25<br>​        raise AttributeError(‘object has no attribute: %s’ % attr)<br>​        # 注意: 只有当属性不存在时 才会调用该方法 且该方法默认返回None 需要在函数最后引发异常<br>​    s &#x3D; Student()<br>​    s.age                                     # s中age属性不存在 故调用__getattr__方法 返回25<br>​    # (5)__call__方法: 定制类的’可调用’性<br>​    class Student(object):<br>​        def <strong>call</strong>(self):                   # 也可以带参数<br>​            print(‘Calling……’)<br>​    s &#x3D; Student()<br>​    s()                                       # s变成了可调用的 也可以带参数<br>​    callable(s)                               # 测试s的可调用性 返回True<br>​    #    (6)__len__方法：求类的长度<br>​    def <strong>len</strong>(self):<br>​        return len(self.data)<br>​<br>#– 动态创建类type()<br>​    # 一般创建类 需要在代码中提前定义<br>​        class Hello(object):<br>​            def hello(self, name&#x3D;’world’):<br>​                print(‘Hello, %s.’ % name)<br>​        h &#x3D; Hello()<br>​        h.hello()                             # Hello, world<br>​        type(Hello)                           # Hello是一个type类型 返回&lt;class ‘type’&gt;<br>​        type(h)                               # h是一个Hello类型 返回&lt;class ‘Hello’&gt;<br>​    # 动态类型语言中 类可以动态创建 type函数可用于创建新类型<br>​        def fn(self, name&#x3D;’world’):           # 先定义函数<br>​            print(‘Hello, %s.’ % name)<br>​        Hello &#x3D; type(‘Hello’, (object,), dict(hello&#x3D;fn))<br>​        # 创建Hello类 type原型: type(name, bases, dict)<br>​        h &#x3D; Hello()                           # 此时的h和上边的h一致</p>
<h1 id="13-异常"><a href="#13-异常" class="headerlink" title="13.异常"></a>13.异常</h1><p>“””异常相关—-异常相关—-异常相关—-异常相关—-异常相关—-异常相关—-异常相关—-异常相关—-异常相关—-异常相关—-异常相关—-异常相关—-异常相关”””<br>​<br>#– #捕获异常:<br>​        try:<br>​        except:                               # 捕获所有的异常 等同于except Exception:<br>​        except name:                          # 捕获指定的异常<br>​        except name, value:                   # 捕获指定的异常和额外的数据(实例)<br>​        except (name1, name2):<br>​        except (name1, name2), value:<br>​        except name4 as X:<br>​        else:                                 # 如果没有发生异常<br>​        finally:                              # 总会执行的部分<br>​    # 引发异常: raise子句(raise IndexError)<br>​        raise <instance>                      # raise instance of a class, raise IndexError()<br>​        raise <class>                         # make and raise instance of a class, raise IndexError<br>​        raise                                 # reraise the most recent exception</p>
<p>#– Python3.x中的异常链: raise exception from otherException<br>​    except Exception as X:<br>​        raise IndexError(‘Bad’) from X<br>​<br>#– assert子句: assert <test>, <data><br>​    assert x &lt; 0, ‘x must be negative’<br>​<br>#– with&#x2F;as环境管理器:作为常见的try&#x2F;finally用法模式的替代方案<br>​    with expression [as variable], expression [as variable]:<br>​    # 例子:<br>​        with open(‘test.txt’) as myfile:<br>​            for line in myfile: print(line)<br>​    # 等同于:<br>​        myfile &#x3D; open(‘test.txt’)<br>​        try:<br>​            for line in myfile: print(line)<br>​        finally:<br>​            myfile.close()</p>
<p>#– 用户自定义异常: class Bad(Exception):…..<br>​    “””<br>​    Exception超类 &#x2F; except基类即可捕获到其所有子类<br>​    Exception超类有默认的打印消息和状态 当然也可以定制打印显示:<br>​    “””<br>​    class MyBad(Exception):<br>​        def <strong>str</strong>(self):<br>​            return ‘定制的打印消息’<br>​    try:<br>​        MyBad()<br>​    except MyBad as x:<br>​        print(x)<br>​<br>#– 用户定制异常数据<br>​    class FormatError(Exception):<br>​        def <strong>init</strong>(self, line ,file):<br>​            self.line &#x3D; line<br>​            self.file &#x3D; file<br>​    try:<br>​        raise FormatError(42, ‘test.py’)<br>​    except FormatError as X:<br>​        print(‘Error at ‘, X.file, X.line)<br>​    # 用户定制异常行为(方法):以记录日志为例<br>​    class FormatError(Exception):<br>​        logfile &#x3D; ‘formaterror.txt’<br>​        def <strong>init</strong>(self, line ,file):<br>​            self.line &#x3D; line<br>​            self.file &#x3D; file<br>​        def logger(self):<br>​            open(self.logfile, ‘a’).write(‘Error at ‘, self.file, self.line)<br>​    try:<br>​        raise FormatError(42, ‘test.py’)<br>​    except FormatError as X:<br>​        X.logger()</p>
<p>#– 关于sys.exc_info:允许一个异常处理器获取对最近引发的异常的访问<br>​    try:<br>​        ……<br>​    except:<br>​        # 此时sys.exc_info()返回一个元组(type, value, traceback)<br>​        # type:正在处理的异常的异常类型<br>​        # value:引发的异常的实例<br>​        # traceback:堆栈信息<br>​<br>#– 异常层次<br>​    BaseException<br>​    +– SystemExit<br>​    +– KeyboardInterrupt<br>​    +– GeneratorExit<br>​    +– Exception<br>​        +– StopIteration<br>​        +– ArithmeticError<br>​        +– AssertionError<br>​        +– AttributeError<br>​        +– BufferError<br>​        +– EOFError<br>​        +– ImportError<br>​        +– LookupError<br>​        +– MemoryError<br>​        +– NameError<br>​        +– OSError<br>​        +– ReferenceError<br>​        +– RuntimeError<br>​        +– SyntaxError<br>​        +– SystemError<br>​        +– TypeError<br>​        +– ValueError<br>​        +– Warning</p>
<p>“””Unicode和字节字符串—Unicode和字节字符串—-Unicode和字节字符串—-Unicode和字节字符串—-Unicode和字节字符串—-Unicode和字节字符串—-Unicode和字节字符串”””</p>
<p>#– Python的字符串类型<br>​    “””Python2.x”””<br>​    # 1.str表示8位文本和二进制数据<br>​    # 2.unicode表示宽字符Unicode文本<br>​    “””Python3.x”””<br>​    # 1.str表示Unicode文本（8位或者更宽）<br>​    # 2.bytes表示不可变的二进制数据<br>​    # 3.bytearray是一种可变的bytes类型</p>
<p>#– 字符编码方法<br>​    “””ASCII”””                   # 一个字节，只包含英文字符，0到127，共128个字符，利用函数可以进行字符和数字的相互转换<br>​    ord(‘a’)                      # 字符a的ASCII码为97，所以这里返回97<br>​    chr(97)                       # 和上边的过程相反，返回字符’a’<br>​    “””Latin-1”””                 # 一个字节，包含特殊字符，0到255，共256个字符，相当于对ASCII码的扩展<br>​    chr(196)                      # 返回一个特殊字符：Ä<br>​    “””Unicode”””                 # 宽字符，一个字符包含多个字节，一般用于亚洲的字符集，比如中文有好几万字<br>​    “””UTF-8”””                   # 可变字节数，小于128的字符表示为单个字节，128到0X7FF之间的代码转换为两个字节，0X7FF以上的代码转换为3或4个字节<br>​    # 注意：可以看出来，ASCII码是Latin-1和UTF-8的一个子集<br>​    # 注意：utf-8是unicode的一种实现方式，unicode、gbk、gb2312是编码字符集<br>​<br>#– 查看Python中的字符串编码名称，查看系统的编码<br>​    import encodings<br>​    help(encoding)<br>​    import sys<br>​    sys.platform                  # ‘win64’<br>​    sys.getdefaultencoding()      # ‘utf-8’<br>​    sys.getdefaultencoding()      # 返回当前系统平台的编码类型<br>​    sys.getsizeof(object)         # 返回object占有的bytes的大小<br>​<br>#– 源文件字符集编码声明: 添加注释来指定想要的编码形式 从而改变默认值 注释必须出现在脚本的第一行或者第二行<br>​    “””说明：其实这里只会检查#和coding:utf-8，其余的字符都是为了美观加上的”””<br>​    # <em>*</em> coding: utf-8 <em>*</em><br>​    # coding &#x3D; utf-8<br>​<br>#– #编码: 字符串 –&gt; 原始字节       #解码: 原始字节 –&gt; 字符串</p>
<p>#– Python3.x中的字符串应用<br>​    s &#x3D; ‘…’                     # 构建一个str对象，不可变对象<br>​    b &#x3D; b’…’                    # 构建一个bytes对象，不可变对象<br>​    s[0], b[0]                    # 返回(‘.’, 113)<br>​    s[1:], b[1:]                  # 返回(‘..’, b’..’)<br>​    B &#x3D; B”””<br>​        xxxx<br>​        yyyy<br>​        “””<br>​    # B &#x3D; b’\nxxxx\nyyyy\n’<br>​    # 编码，将str字符串转化为其raw bytes形式：<br>​        str.encode(encoding &#x3D; ‘utf-8’, errors &#x3D; ‘strict’)<br>​        bytes(str, encoding)<br>​    # 编码例子：<br>​        S &#x3D; ‘egg’<br>​        S.encode()                    # b’egg’<br>​        bytes(S, encoding &#x3D; ‘ascii’)  # b’egg’<br>​    # 解码，将raw bytes字符串转化为str形式：<br>​        bytes.decode(encoding &#x3D; ‘utf-8’, errors &#x3D; ‘strict’)<br>​        str(bytes_or_buffer[, encoding[, errors]])<br>​    # 解码例子：<br>​        B &#x3D; b’spam’<br>​        B.decode()                # ‘spam’<br>​        str(B)                    # “b’spam’”，不带编码的str调用，结果为打印该bytes对象<br>​        str(B, encoding &#x3D; ‘ascii’)# ‘spam’，带编码的str调用，结果为转化该bytes对象<br>​<br>#– Python2.x的编码问题<br>​    u &#x3D; u’汉’<br>​    print repr(u)                 # u’\xba\xba’<br>​    s &#x3D; u.encode(‘UTF-8’)<br>​    print repr(s)                 # ‘\xc2\xba\xc2\xba’<br>​    u2 &#x3D; s.decode(‘UTF-8’)<br>​    print repr(u2)                # u’\xba\xba’<br>​    # 对unicode进行解码是错误的<br>​    s2 &#x3D; u.decode(‘UTF-8’)        # UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 0-1: ordinal not in range(128)<br>​    # 同样，对str进行编码也是错误的<br>​    u2 &#x3D; s.encode(‘UTF-8’)        # UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xc2 in position 0: ordinal not in range(128)</p>
<p>#– bytes对象<br>​    B &#x3D; b’abc’<br>​    B &#x3D; bytes(‘abc’, ‘ascii’)<br>​    B &#x3D; bytes([97, 98, 99])<br>​    B &#x3D; ‘abc’.encode()<br>​    # bytes对象的方法调用基本和str类型一致 但:B[0]返回的是ASCII码值97, 而不是b’a’<br>​<br>#– #文本文件: 根据Unicode编码来解释文件内容，要么是平台的默认编码，要么是指定的编码类型<br>​    # 二进制文件：表示字节值的整数的一个序列 open(‘bin.txt’, ‘rb’)<br>​<br>#– Unicode文件<br>​    s &#x3D; ‘A\xc4B\xe8C’             # s &#x3D; ‘A?BèC’  len(s) &#x3D; 5<br>​    #手动编码<br>​        l &#x3D; s.encode(‘latin-1’)   # l &#x3D; b’A\xc4B\xe8C’  len(l) &#x3D; 5<br>​        u &#x3D; s.encode(‘utf-8’)     # u &#x3D; b’A\xc3\x84B\xc3\xa8C’  len(u) &#x3D; 7<br>​    #文件输出编码<br>​        open(‘latindata’, ‘w’, encoding &#x3D; ‘latin-1’).write(s)<br>​        l &#x3D; open(‘latindata’, ‘rb’).read()                        # l &#x3D; b’A\xc4B\xe8C’  len(l) &#x3D; 5<br>​        open(‘uft8data’, ‘w’, encoding &#x3D; ‘utf-8’).write(s)<br>​        u &#x3D; open(‘uft8data’, ‘rb’).read()                         # u &#x3D; b’A\xc3\x84B\xc3\xa8C’  len(u) &#x3D; 7<br>​    #文件输入编码<br>​        s &#x3D; open(‘latindata’, ‘r’, encoding &#x3D; ‘latin-1’).read()   # s &#x3D; ‘A?BèC’  len(s) &#x3D; 5<br>​        s &#x3D; open(‘latindata’, ‘rb’).read().decode(‘latin-1’)      # s &#x3D; ‘A?BèC’  len(s) &#x3D; 5<br>​        s &#x3D; open(‘utf8data’, ‘r’, encoding &#x3D; ‘utf-8’).read()      # s &#x3D; ‘A?BèC’  len(s) &#x3D; 5<br>​        s &#x3D; open(‘utf8data’, ‘rb’).read().decode(‘utf-8’)         # s &#x3D; ‘A?BèC’  len(s) &#x3D; 5<br>​        </p>
<h1 id="14-其他"><a href="#14-其他" class="headerlink" title="14.其他"></a>14.其他</h1><p>“””其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他—-其他”””</p>
<p>#– Python实现任意深度的赋值 例如a[0] &#x3D; ‘value1’; a[1][2] &#x3D; ‘value2’; a[3][4][5] &#x3D; ‘value3’<br>​    class MyDict(dict):<br>​        def <strong>setitem</strong>(self, key, value):                 # 该函数不做任何改动 这里只是为了输出<br>​            print(‘setitem:’, key, value, self)<br>​            super().<strong>setitem</strong>(key, value)<br>​        def <strong>getitem</strong>(self, item):                       # 主要技巧在该函数<br>​            print(‘getitem:’, item, self)                  # 输出信息<br>​            # 基本思路: a[1][2]赋值时 需要先取出a[1] 然后给a[1]的[2]赋值<br>​            if item not in self:                           # 如果a[1]不存在 则需要新建一个dict 并使得a[1] &#x3D; dict<br>​                temp &#x3D; MyDict()                            # 新建的dict: temp<br>​                super().<strong>setitem</strong>(item, temp)            # 赋值a[1] &#x3D; temp<br>​                return temp                                # 返回temp 使得temp[2] &#x3D; value有效<br>​            return super().<strong>getitem</strong>(item)               # 如果a[1]存在 则直接返回a[1]<br>​    # 例子:<br>​        test &#x3D; MyDict()<br>​        test[0] &#x3D; ‘test’<br>​        print(test[0])<br>​        test[1][2] &#x3D; ‘test1’<br>​        print(test[1][2])<br>​        test[1][3] &#x3D; ‘test2’<br>​        print(test[1][3])</p>
<p>#– Python中的多维数组<br>​    lists &#x3D; [0] * 3                                        # 扩展list，结果为[0, 0, 0]<br>​    lists &#x3D; [[]] * 3                                       # 多维数组，结果为[[], [], []]，但有问题，往下看<br>​    lists[0].append(3)                                     # 期望看到的结果[[3], [], []]，实际结果[[3], [3], [3]]，原因：list*n操作，是浅拷贝，如何避免？往下看<br>​    lists &#x3D; [[] for i in range(3)]                         # 多维数组，结果为[[], [], []]<br>​    lists[0].append(3)                                     # 结果为[[3], [], []]<br>​    lists[1].append(6)                                     # 结果为[[3], [6], []]<br>​    lists[2].append(9)                                     # 结果为[[3], [6], [9]]<br>​    lists &#x3D; [[[] for j in range(4)] for i in range(3)]     # 3行4列，且每一个元素为[]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/damei6677/python/python%E5%AD%A6%E4%B9%A0.html" data-id="clji7crq0001i6s4lal8j2q40" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2023/06/">June 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2023/06/30/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/blog/js/jquery-3.6.4.min.js"></script>



  
<script src="/blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/blog/js/script.js"></script>





  </div>
</body>
</html>